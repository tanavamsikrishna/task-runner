#!/usr/bin/env lua

local function load_tasks()
    local task_file_load_success, tasks = pcall(require, "tasks")
    if not task_file_load_success then
        io.stderr:write("No tasks file found found.\n" .. tasks .. "\n")
        os.exit(false)
    elseif type(tasks) ~= "table" then
        io.stderr:write("Tasks file need to return a tasks table.\n")
        os.exit(false)
    end
    return tasks
end

---@param task_seq string[]
local function execute_task(task_seq, tasks)
    for _, task_name in ipairs(task_seq) do
        if type(tasks) == "table" and tasks[task_name] ~= nil then
            tasks = tasks[task_name]
        else
            return false, "Task `" .. table.concat(task_seq, " ") .. "` not found"
        end
    end

    if type(tasks) == "function" then
        tasks()
    elseif type(tasks) == "table" and type(tasks._action) == "function" then
        tasks._action()
    elseif type(tasks) == "string" then
        io.stdout:write("Running `" .. tasks .. "`\n")
        require("task_runner.helpers").shell(tasks)
    else
        return false, "Task `" .. table.concat(task_seq, " ") .. "` is not a runnable"
    end
    return true
end

local function build_help(task_tree, lines, parent_path)
    local parent_path_str = table.concat(parent_path, ".")
    if type(task_tree) == "function" then
        table.insert(lines, { parent_path_str, "" })
        return
    elseif type(task_tree) == "string" then
        table.insert(lines, { parent_path_str, "$ " .. task_tree })
        return
    end
    for k, v in pairs(task_tree) do
        if k == "_desc" then
            table.insert(lines, { parent_path_str, v })
        elseif k == "_action" then
        else
            table.insert(parent_path, k)
            build_help(v, lines, parent_path)
            table.remove(parent_path, #parent_path)
        end
    end
end

local function print_two_column_table(lines)
    table.sort(lines, function(e1, e2)
        return e1[1] < e2[1]
    end)
    local max_len = 0
    for _, line in ipairs(lines) do
        max_len = math.max(max_len, #line[1])
    end
    io.stdout:write("Tasks:\n")
    for _, line in ipairs(lines) do
        io.stdout:write(
            string.format("%-" .. max_len .. "s   %s\n", line[1], line[2] or "")
        )
    end
end

local function main()
    local tasks = load_tasks()
    if #arg == 0 then
        local help_lines = {}
        build_help(tasks, help_lines, {})
        print_two_column_table(help_lines)
    else
        local success, msg = execute_task(arg, tasks)
        if success then
            return
        end
        io.stderr:write(msg .. "\n")
    end
end

main()
