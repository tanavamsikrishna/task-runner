#!/usr/bin/env lua

local function load_tasks()
    local task_file_load_success, tasks = pcall(require, "tasks")
    if not task_file_load_success then
        io.stderr:write("No tasks file found found\n")
        os.exit(false)
    elseif type(tasks) ~= "table" then
        io.stderr:write("Tasks file need to return a tasks table.\n")
        os.exit(false)
    end
    return tasks
end

local function execute_runnable(runnable, is_empty_ok)
    if runnable == nil then
        return is_empty_ok
    elseif type(runnable) == "string" then
        io.stdout:write("Running `" .. runnable .. "`\n")
        require("task_runner.helpers").shell(runnable)
    elseif type(runnable) == "function" then
        runnable()
    else
        return false
    end
    return true
end

---@param task_seq string[]
---@param tasks table<string, table|function|string>|string|function
local function execute_task(task_seq, tasks)
    local setup_function = nil
    if tasks._setup ~= nil then
        setup_function = tasks._setup
    end
    for _, task_name in ipairs(task_seq) do
        if type(tasks) == "table" and tasks[task_name] ~= nil then
            if tasks._setup ~= nil then
                setup_function = tasks._setup
            end
            tasks = tasks[task_name]
        else
            return false, "Task `" .. table.concat(task_seq, " ") .. "` not found"
        end
    end

    if type(tasks) == "table" then
        if tasks._setup ~= nil then
            setup_function = tasks._setup
        end
        if tasks._action ~= nil then
            tasks = tasks._action
        end
    end

    if not execute_runnable(setup_function, true) then
        return false, "Setup for `" .. table.concat(task_seq, " ") .. "` is not a runnable"
    end
    if not execute_runnable(tasks, false) then
        return false, "Action for `" .. table.concat(task_seq, " ") .. "` is not a runnable"
    end
    return true
end

local function build_help(task_tree, lines, parent_path)
    local parent_path_str = table.concat(parent_path, " ")
    if type(task_tree) == "function" then
        table.insert(lines, { parent_path_str, "" })
        return
    elseif type(task_tree) == "string" then
        table.insert(lines, { parent_path_str, "$ " .. task_tree })
        return
    end
    for k, v in pairs(task_tree) do
        if k == "_desc" then
            table.insert(lines, { parent_path_str, v })
        elseif k == "_action" and type(v) == "string" then
            table.insert(lines, { parent_path_str, "$ " .. v })
        elseif k == "_action" or k == "_setup" then
        else
            table.insert(parent_path, k)
            build_help(v, lines, parent_path)
            table.remove(parent_path, #parent_path)
        end
    end
end

local function print_two_column_table(lines)
    table.sort(lines, function(e1, e2)
        return e1[1] < e2[1]
    end)
    local max_len = 0
    for _, line in ipairs(lines) do
        max_len = math.max(max_len, #line[1])
    end
    io.stdout:write("Tasks:\n")
    for _, line in ipairs(lines) do
        io.stdout:write(string.format("%-" .. max_len .. "s   %s\n", line[1], line[2] or ""))
    end
end

local function main()
    local tasks = load_tasks()
    if #arg == 0 then
        local help_lines = {}
        build_help(tasks, help_lines, {})
        print_two_column_table(help_lines)
    else
        local success, msg = execute_task(arg, tasks)
        if not success then
            io.stderr:write(msg .. "\n")
        end
    end
end

main()
